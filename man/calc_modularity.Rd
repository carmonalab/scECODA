% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotting.r
\name{calc_modularity}
\alias{calc_modularity}
\title{Calculate Adjusted Modularity Score}
\usage{
calc_modularity(feat_mat, labels, knn_k = 3, digits = 3)
}
\arguments{
\item{feat_mat}{Numeric matrix or data frame. The feature matrix used to
compute distances (e.g., CLR abundances).}

\item{labels}{Vector of factors or character strings. The cluster assignments
for each row in \code{feat_mat}.}

\item{knn_k}{Integer (optional, default: \code{NULL}). The number of nearest
neighbors (\code{k}) used for SNN graph construction. If \code{NULL}, it
defaults to \code{max(3, round(sqrt(N)))}, where \code{N} is the number of
samples.}

\item{digits}{Integer (default: \code{3}). The number of decimal places to
round the final adjusted score.}
}
\value{
A numeric value representing the adjusted modularity score,
ranging from -0.5 to 1.0.
}
\description{
Calculates the Modularity score for a given clustering (\code{labels}) based
on a Shared Nearest Neighbor (SNN) graph.The score is adjusted by the
theoretical maximum modularity for the number of groups to always be between
-0.5 (poor clustering) and +1 (excellent clustering)).
}
\examples{
data(example_data)
ecoda_object <- ecoda(
    data = example_data$GongSharma_full$cell_counts_highresolution,
    metadata = example_data$GongSharma_full$metadata
)

# Extract necessary components
feat_mat <- slot(ecoda_object, "clr")
labels <- slot(ecoda_object, "metadata")$subject.cmv

# Run the calculation
calc_modularity(feat_mat, labels)
}
\references{
Brandes, Ulrik, et al.
"On finding graph clusterings with maximum modularity."
European Symposium on Algorithms. Springer, Berlin, Heidelberg, 2007.
}
